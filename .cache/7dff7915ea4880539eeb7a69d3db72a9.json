{"dependencies":[{"name":"../utils/params","loc":{"line":1,"column":53}},{"name":"../utils/dom/index","loc":{"line":2,"column":21}},{"name":"../utils/classes","loc":{"line":3,"column":28}},{"name":"../utils/Timer","loc":{"line":4,"column":18}},{"name":"../utils/utils","loc":{"line":5,"column":76}},{"name":"../utils/setParameters","loc":{"line":6,"column":26}},{"name":"../globalState","loc":{"line":7,"column":24}},{"name":"../utils/openPopup","loc":{"line":8,"column":26}},{"name":"../privateProps","loc":{"line":9,"column":25}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._main = _main;\n\nvar _params = require(\"../utils/params\");\n\nvar _params2 = _interopRequireDefault(_params);\n\nvar _index = require(\"../utils/dom/index\");\n\nvar dom = _interopRequireWildcard(_index);\n\nvar _classes = require(\"../utils/classes\");\n\nvar _Timer = require(\"../utils/Timer\");\n\nvar _Timer2 = _interopRequireDefault(_Timer);\n\nvar _utils = require(\"../utils/utils\");\n\nvar _setParameters = require(\"../utils/setParameters\");\n\nvar _setParameters2 = _interopRequireDefault(_setParameters);\n\nvar _globalState = require(\"../globalState\");\n\nvar _globalState2 = _interopRequireDefault(_globalState);\n\nvar _openPopup = require(\"../utils/openPopup\");\n\nvar _privateProps = require(\"../privateProps\");\n\nvar _privateProps2 = _interopRequireDefault(_privateProps);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _main(userParams) {\n  (0, _params.showWarningsForParams)(userParams);\n\n  const innerParams = Object.assign({}, _params2.default, userParams);\n  (0, _setParameters2.default)(innerParams);\n  Object.freeze(innerParams);\n  _privateProps2.default.innerParams.set(this, innerParams);\n\n  // clear the previous timer\n  if (_globalState2.default.timeout) {\n    _globalState2.default.timeout.stop();\n    delete _globalState2.default.timeout;\n  }\n\n  // clear the restore focus timeout\n  clearTimeout(_globalState2.default.restoreFocusTimeout);\n\n  const domCache = {\n    popup: dom.getPopup(),\n    container: dom.getContainer(),\n    content: dom.getContent(),\n    actions: dom.getActions(),\n    confirmButton: dom.getConfirmButton(),\n    cancelButton: dom.getCancelButton(),\n    closeButton: dom.getCloseButton(),\n    validationMessage: dom.getValidationMessage(),\n    progressSteps: dom.getProgressSteps()\n  };\n  _privateProps2.default.domCache.set(this, domCache);\n\n  const constructor = this.constructor;\n\n  return new Promise((resolve, reject) => {\n    // functions to handle all resolving/rejecting/settling\n    const succeedWith = value => {\n      constructor.closePopup(innerParams.onClose, innerParams.onAfterClose); // TODO: make closePopup an *instance* method\n      if (innerParams.useRejections) {\n        resolve(value);\n      } else {\n        resolve({ value });\n      }\n    };\n    const dismissWith = dismiss => {\n      constructor.closePopup(innerParams.onClose, innerParams.onAfterClose);\n      if (innerParams.useRejections) {\n        reject(dismiss);\n      } else {\n        resolve({ dismiss });\n      }\n    };\n    const errorWith = error => {\n      constructor.closePopup(innerParams.onClose, innerParams.onAfterClose);\n      reject(error);\n    };\n\n    // Close on timer\n    if (innerParams.timer) {\n      _globalState2.default.timeout = new _Timer2.default(() => {\n        dismissWith('timer');\n        delete _globalState2.default.timeout;\n      }, innerParams.timer);\n    }\n\n    // Get the value of the popup input\n    const getInputValue = () => {\n      const input = this.getInput();\n      if (!input) {\n        return null;\n      }\n      switch (innerParams.input) {\n        case 'checkbox':\n          return input.checked ? 1 : 0;\n        case 'radio':\n          return input.checked ? input.value : null;\n        case 'file':\n          return input.files.length ? input.files[0] : null;\n        default:\n          return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n      }\n    };\n\n    // input autofocus\n    if (innerParams.input) {\n      setTimeout(() => {\n        const input = this.getInput();\n        if (input) {\n          dom.focusInput(input);\n        }\n      }, 0);\n    }\n\n    const confirm = value => {\n      if (innerParams.showLoaderOnConfirm) {\n        constructor.showLoading(); // TODO: make showLoading an *instance* method\n      }\n\n      if (innerParams.preConfirm) {\n        this.resetValidationMessage();\n        const preConfirmPromise = Promise.resolve().then(() => innerParams.preConfirm(value, innerParams.extraParams));\n        if (innerParams.expectRejections) {\n          preConfirmPromise.then(preConfirmValue => succeedWith(preConfirmValue || value), validationMessage => {\n            this.hideLoading();\n            if (validationMessage) {\n              this.showValidationMessage(validationMessage);\n            }\n          });\n        } else {\n          preConfirmPromise.then(preConfirmValue => {\n            if (dom.isVisible(domCache.validationMessage) || preConfirmValue === false) {\n              this.hideLoading();\n            } else {\n              succeedWith(preConfirmValue || value);\n            }\n          }, error => errorWith(error));\n        }\n      } else {\n        succeedWith(value);\n      }\n    };\n\n    // Mouse interactions\n    const onButtonEvent = e => {\n      const target = e.target;\n      const { confirmButton, cancelButton } = domCache;\n      const targetedConfirm = confirmButton && (confirmButton === target || confirmButton.contains(target));\n      const targetedCancel = cancelButton && (cancelButton === target || cancelButton.contains(target));\n\n      switch (e.type) {\n        case 'click':\n          // Clicked 'confirm'\n          if (targetedConfirm && constructor.isVisible()) {\n            this.disableButtons();\n            if (innerParams.input) {\n              const inputValue = getInputValue();\n\n              if (innerParams.inputValidator) {\n                this.disableInput();\n                const validationPromise = Promise.resolve().then(() => innerParams.inputValidator(inputValue, innerParams.extraParams));\n                if (innerParams.expectRejections) {\n                  validationPromise.then(() => {\n                    this.enableButtons();\n                    this.enableInput();\n                    confirm(inputValue);\n                  }, validationMessage => {\n                    this.enableButtons();\n                    this.enableInput();\n                    if (validationMessage) {\n                      this.showValidationMessage(validationMessage);\n                    }\n                  });\n                } else {\n                  validationPromise.then(validationMessage => {\n                    this.enableButtons();\n                    this.enableInput();\n                    if (validationMessage) {\n                      this.showValidationMessage(validationMessage);\n                    } else {\n                      confirm(inputValue);\n                    }\n                  }, error => errorWith(error));\n                }\n              } else {\n                confirm(inputValue);\n              }\n            } else {\n              confirm(true);\n            }\n\n            // Clicked 'cancel'\n          } else if (targetedCancel && constructor.isVisible()) {\n            this.disableButtons();\n            dismissWith(constructor.DismissReason.cancel);\n          }\n          break;\n        default:\n      }\n    };\n\n    const buttons = domCache.popup.querySelectorAll('button');\n    for (let i = 0; i < buttons.length; i++) {\n      buttons[i].onclick = onButtonEvent;\n      buttons[i].onmouseover = onButtonEvent;\n      buttons[i].onmouseout = onButtonEvent;\n      buttons[i].onmousedown = onButtonEvent;\n    }\n\n    // Closing popup by close button\n    domCache.closeButton.onclick = () => {\n      dismissWith(constructor.DismissReason.close);\n    };\n\n    if (innerParams.toast) {\n      // Closing popup by internal click\n      domCache.popup.onclick = () => {\n        if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {\n          return;\n        }\n        dismissWith(constructor.DismissReason.close);\n      };\n    } else {\n      let ignoreOutsideClick = false;\n\n      // Ignore click events that had mousedown on the popup but mouseup on the container\n      // This can happen when the user drags a slider\n      domCache.popup.onmousedown = () => {\n        domCache.container.onmouseup = function (e) {\n          domCache.container.onmouseup = undefined;\n          // We only check if the mouseup target is the container because usually it doesn't\n          // have any other direct children aside of the popup\n          if (e.target === domCache.container) {\n            ignoreOutsideClick = true;\n          }\n        };\n      };\n\n      // Ignore click events that had mousedown on the container but mouseup on the popup\n      domCache.container.onmousedown = () => {\n        domCache.popup.onmouseup = function (e) {\n          domCache.popup.onmouseup = undefined;\n          // We also need to check if the mouseup target is a child of the popup\n          if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n            ignoreOutsideClick = true;\n          }\n        };\n      };\n\n      domCache.container.onclick = e => {\n        if (ignoreOutsideClick) {\n          ignoreOutsideClick = false;\n          return;\n        }\n        if (e.target !== domCache.container) {\n          return;\n        }\n        if ((0, _utils.callIfFunction)(innerParams.allowOutsideClick)) {\n          dismissWith(constructor.DismissReason.backdrop);\n        }\n      };\n    }\n\n    // Reverse buttons (Confirm on the right side)\n    if (innerParams.reverseButtons) {\n      domCache.confirmButton.parentNode.insertBefore(domCache.cancelButton, domCache.confirmButton);\n    } else {\n      domCache.confirmButton.parentNode.insertBefore(domCache.confirmButton, domCache.cancelButton);\n    }\n\n    // Focus handling\n    const setFocus = (index, increment) => {\n      const focusableElements = dom.getFocusableElements(innerParams.focusCancel);\n      // search for visible elements and select the next possible match\n      for (let i = 0; i < focusableElements.length; i++) {\n        index = index + increment;\n\n        // rollover to first item\n        if (index === focusableElements.length) {\n          index = 0;\n\n          // go to last item\n        } else if (index === -1) {\n          index = focusableElements.length - 1;\n        }\n\n        return focusableElements[index].focus();\n      }\n      // no visible focusable elements, focus the popup\n      domCache.popup.focus();\n    };\n\n    const keydownHandler = (e, innerParams) => {\n      if (innerParams.stopKeydownPropagation) {\n        e.stopPropagation();\n      }\n\n      const arrowKeys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Left', 'Right', 'Up', 'Down' // IE11\n      ];\n\n      if (e.key === 'Enter' && !e.isComposing) {\n        if (e.target && this.getInput() && e.target.outerHTML === this.getInput().outerHTML) {\n          if (['textarea', 'file'].includes(innerParams.input)) {\n            return; // do not submit\n          }\n\n          constructor.clickConfirm();\n          e.preventDefault();\n        }\n\n        // TAB\n      } else if (e.key === 'Tab') {\n        const targetElement = e.target;\n\n        const focusableElements = dom.getFocusableElements(innerParams.focusCancel);\n        let btnIndex = -1;\n        for (let i = 0; i < focusableElements.length; i++) {\n          if (targetElement === focusableElements[i]) {\n            btnIndex = i;\n            break;\n          }\n        }\n\n        if (!e.shiftKey) {\n          // Cycle to the next button\n          setFocus(btnIndex, 1);\n        } else {\n          // Cycle to the prev button\n          setFocus(btnIndex, -1);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n\n        // ARROWS - switch focus between buttons\n      } else if (arrowKeys.includes(e.key)) {\n        // focus Cancel button if Confirm button is currently focused\n        if (document.activeElement === domCache.confirmButton && dom.isVisible(domCache.cancelButton)) {\n          domCache.cancelButton.focus();\n          // and vice versa\n        } else if (document.activeElement === domCache.cancelButton && dom.isVisible(domCache.confirmButton)) {\n          domCache.confirmButton.focus();\n        }\n\n        // ESC\n      } else if ((e.key === 'Escape' || e.key === 'Esc') && (0, _utils.callIfFunction)(innerParams.allowEscapeKey) === true) {\n        e.preventDefault();\n        dismissWith(constructor.DismissReason.esc);\n      }\n    };\n\n    if (_globalState2.default.keydownHandlerAdded) {\n      _globalState2.default.keydownTarget.removeEventListener('keydown', _globalState2.default.keydownHandler, { capture: _globalState2.default.keydownListenerCapture });\n      _globalState2.default.keydownHandlerAdded = false;\n    }\n\n    if (!innerParams.toast) {\n      _globalState2.default.keydownHandler = e => keydownHandler(e, innerParams);\n      _globalState2.default.keydownTarget = innerParams.keydownListenerCapture ? window : domCache.popup;\n      _globalState2.default.keydownListenerCapture = innerParams.keydownListenerCapture;\n      _globalState2.default.keydownTarget.addEventListener('keydown', _globalState2.default.keydownHandler, { capture: _globalState2.default.keydownListenerCapture });\n      _globalState2.default.keydownHandlerAdded = true;\n    }\n\n    this.enableButtons();\n    this.hideLoading();\n    this.resetValidationMessage();\n\n    if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {\n      dom.addClass(document.body, _classes.swalClasses['toast-column']);\n    } else {\n      dom.removeClass(document.body, _classes.swalClasses['toast-column']);\n    }\n\n    // inputs\n    const inputTypes = ['input', 'file', 'range', 'select', 'radio', 'checkbox', 'textarea'];\n    let input;\n    for (let i = 0; i < inputTypes.length; i++) {\n      const inputClass = _classes.swalClasses[inputTypes[i]];\n      const inputContainer = dom.getChildByClass(domCache.content, inputClass);\n      input = this.getInput(inputTypes[i]);\n\n      // set attributes\n      if (input) {\n        for (let j in input.attributes) {\n          if (input.attributes.hasOwnProperty(j)) {\n            const attrName = input.attributes[j].name;\n            if (attrName !== 'type' && attrName !== 'value') {\n              input.removeAttribute(attrName);\n            }\n          }\n        }\n        for (let attr in innerParams.inputAttributes) {\n          input.setAttribute(attr, innerParams.inputAttributes[attr]);\n        }\n      }\n\n      // set class\n      inputContainer.className = inputClass;\n      if (innerParams.inputClass) {\n        dom.addClass(inputContainer, innerParams.inputClass);\n      }\n\n      dom.hide(inputContainer);\n    }\n\n    let populateInputOptions;\n    switch (innerParams.input) {\n      case 'text':\n      case 'email':\n      case 'password':\n      case 'number':\n      case 'tel':\n      case 'url':\n        {\n          input = dom.getChildByClass(domCache.content, _classes.swalClasses.input);\n          if (typeof innerParams.inputValue === 'string' || typeof innerParams.inputValue === 'number') {\n            input.value = innerParams.inputValue;\n          } else {\n            (0, _utils.warn)(`Unexpected type of inputValue! Expected \"string\" or \"number\", got \"${typeof innerParams.inputValue}\"`);\n          }\n          input.placeholder = innerParams.inputPlaceholder;\n          input.type = innerParams.input;\n          dom.show(input);\n          break;\n        }\n      case 'file':\n        {\n          input = dom.getChildByClass(domCache.content, _classes.swalClasses.file);\n          input.placeholder = innerParams.inputPlaceholder;\n          input.type = innerParams.input;\n          dom.show(input);\n          break;\n        }\n      case 'range':\n        {\n          const range = dom.getChildByClass(domCache.content, _classes.swalClasses.range);\n          const rangeInput = range.querySelector('input');\n          const rangeOutput = range.querySelector('output');\n          rangeInput.value = innerParams.inputValue;\n          rangeInput.type = innerParams.input;\n          rangeOutput.value = innerParams.inputValue;\n          dom.show(range);\n          break;\n        }\n      case 'select':\n        {\n          const select = dom.getChildByClass(domCache.content, _classes.swalClasses.select);\n          select.innerHTML = '';\n          if (innerParams.inputPlaceholder) {\n            const placeholder = document.createElement('option');\n            placeholder.innerHTML = innerParams.inputPlaceholder;\n            placeholder.value = '';\n            placeholder.disabled = true;\n            placeholder.selected = true;\n            select.appendChild(placeholder);\n          }\n          populateInputOptions = inputOptions => {\n            inputOptions.forEach(inputOption => {\n              const optionValue = inputOption[0];\n              const optionLabel = inputOption[1];\n              const option = document.createElement('option');\n              option.value = optionValue;\n              option.innerHTML = optionLabel;\n              if (innerParams.inputValue.toString() === optionValue.toString()) {\n                option.selected = true;\n              }\n              select.appendChild(option);\n            });\n            dom.show(select);\n            select.focus();\n          };\n          break;\n        }\n      case 'radio':\n        {\n          const radio = dom.getChildByClass(domCache.content, _classes.swalClasses.radio);\n          radio.innerHTML = '';\n          populateInputOptions = inputOptions => {\n            inputOptions.forEach(inputOption => {\n              const radioValue = inputOption[0];\n              const radioLabel = inputOption[1];\n              const radioInput = document.createElement('input');\n              const radioLabelElement = document.createElement('label');\n              radioInput.type = 'radio';\n              radioInput.name = _classes.swalClasses.radio;\n              radioInput.value = radioValue;\n              if (innerParams.inputValue.toString() === radioValue.toString()) {\n                radioInput.checked = true;\n              }\n              const label = document.createElement('span');\n              label.innerHTML = radioLabel;\n              label.className = _classes.swalClasses.label;\n              radioLabelElement.appendChild(radioInput);\n              radioLabelElement.appendChild(label);\n              radio.appendChild(radioLabelElement);\n            });\n            dom.show(radio);\n            const radios = radio.querySelectorAll('input');\n            if (radios.length) {\n              radios[0].focus();\n            }\n          };\n          break;\n        }\n      case 'checkbox':\n        {\n          const checkbox = dom.getChildByClass(domCache.content, _classes.swalClasses.checkbox);\n          const checkboxInput = this.getInput('checkbox');\n          checkboxInput.type = 'checkbox';\n          checkboxInput.value = 1;\n          checkboxInput.id = _classes.swalClasses.checkbox;\n          checkboxInput.checked = Boolean(innerParams.inputValue);\n          let label = checkbox.querySelector('span');\n          label.innerHTML = innerParams.inputPlaceholder;\n          dom.show(checkbox);\n          break;\n        }\n      case 'textarea':\n        {\n          const textarea = dom.getChildByClass(domCache.content, _classes.swalClasses.textarea);\n          textarea.value = innerParams.inputValue;\n          textarea.placeholder = innerParams.inputPlaceholder;\n          dom.show(textarea);\n          break;\n        }\n      case null:\n        {\n          break;\n        }\n      default:\n        (0, _utils.error)(`Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"${innerParams.input}\"`);\n        break;\n    }\n\n    if (innerParams.input === 'select' || innerParams.input === 'radio') {\n      const processInputOptions = inputOptions => populateInputOptions((0, _utils.formatInputOptions)(inputOptions));\n      if ((0, _utils.isThenable)(innerParams.inputOptions)) {\n        constructor.showLoading();\n        innerParams.inputOptions.then(inputOptions => {\n          this.hideLoading();\n          processInputOptions(inputOptions);\n        });\n      } else if (typeof innerParams.inputOptions === 'object') {\n        processInputOptions(innerParams.inputOptions);\n      } else {\n        (0, _utils.error)(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof innerParams.inputOptions}`);\n      }\n    } else if (['text', 'email', 'number', 'tel', 'textarea'].includes(innerParams.input) && (0, _utils.isThenable)(innerParams.inputValue)) {\n      constructor.showLoading();\n      dom.hide(input);\n      innerParams.inputValue.then(inputValue => {\n        input.value = innerParams.input === 'number' ? parseFloat(inputValue) || 0 : inputValue + '';\n        dom.show(input);\n        input.focus();\n        this.hideLoading();\n      }).catch(err => {\n        (0, _utils.error)('Error in inputValue promise: ' + err);\n        input.value = '';\n        dom.show(input);\n        input.focus();\n        this.hideLoading();\n      });\n    }\n\n    (0, _openPopup.openPopup)(innerParams);\n\n    if (!innerParams.toast) {\n      if (!(0, _utils.callIfFunction)(innerParams.allowEnterKey)) {\n        if (document.activeElement) {\n          document.activeElement.blur();\n        }\n      } else if (innerParams.focusCancel && dom.isVisible(domCache.cancelButton)) {\n        domCache.cancelButton.focus();\n      } else if (innerParams.focusConfirm && dom.isVisible(domCache.confirmButton)) {\n        domCache.confirmButton.focus();\n      } else {\n        setFocus(-1, 1);\n      }\n    }\n\n    // fix scroll\n    domCache.container.scrollTop = 0;\n  });\n}"},"hash":"e4ea0804db51e8fd3858142e6c114ba1"}